
import java.io.*;
import java.util.ArrayList;
import java.util.ArrayDeque;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

class TorrentInfo {

	String announce;				//tracker announce url
	String creationDate;			//torrent creation date
	String createdBy;				//author for torrent file
	String comment;					//torrent comments
	String encoding;	
	ArrayList<String> announceList;	//list of announce urls
	byte[] infoHash;				//20 byte torrent SHA1 info hash

	public TorrentInfo(String fileName) {
		
		Blex lexTree = new Blex(fileName);
		announceList = new ArrayList<String>();
		infoHash = new byte[20]; 
		
		setInfo(lexTree.tokenList);
		computeInfoHash(lexTree.tokenList, fileName);
	}

	//covert info hash to a hexadecimal string
	public String infoHashString(byte[] a) {
		
		StringBuilder sb = new StringBuilder(a.length * 2);
		
		for(byte b : a) {
			
			sb.append(String.format("%02x", b));
		}
		
		return sb.toString();
	}
	
	//populate instance variables with data from the tokenList generated by the bencoded lexer
	private void setInfo(ArrayList<TokenElement> tokenArray) {
		
		for(int i = 0; i < tokenArray.size(); i++) {
			
			String str = tokenArray.get(i).getValueString();
			
			if (str != null && str.equals("announce")) {
				
				i++;
				this.announce = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("created by")) {
				
				i++;
				this.createdBy = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("creation date")) {
				
				i++;
				this.creationDate = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("comment")) {
				
				i++;
				this.comment = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("encoding")) {
				
				i++;
				this.encoding = tokenArray.get(i).getValueString();

			} else if (str != null && str.equals("announce-list")) {
				
				i++;
				ArrayDeque<TokenElement> announceStack = new ArrayDeque<TokenElement>();		
				announceStack.push(tokenArray.get(i));
				
				//check if there is a list of LIST token on a stack
				while (!announceStack.isEmpty()) {
					
					i++;

					if (tokenArray.get(i).type == TokenElement.Token.END) {
						
						announceStack.pop();

					} else if (tokenArray.get(i).type == TokenElement.Token.LIST) {
						
						announceStack.push(tokenArray.get(i));

					} else if (tokenArray.get(i).type == TokenElement.Token.BYTESTRING) {
						
						this.announceList.add(tokenArray.get(i).getValueString());
					}
				}
			}
		}
	}
	
	//calculate the infoHash
	private void computeInfoHash(ArrayList<TokenElement> tokenList, String fileName) {
		
		TokenElement[] tokenArray = new TokenElement[tokenList.size()];
		long startOffset = 0;
		long endOffset = 0;

		tokenArray = tokenList.toArray(tokenArray);
		
		for (int i = 0; i < tokenArray.length; i++) {
			
			String value = tokenArray[i].getValueString();
			
			//search for the info token
			if (value != null && value.equals("info")) {
				
				TokenElement infoDictionary = tokenArray[i + 1];
				TokenElement endToken = tokenArray[infoDictionary.endIndex];
				startOffset = infoDictionary.position - 1;//the read() function will consume the next by so set it 1 position back
				endOffset = endToken.position;
			}
		}

		try (FileInputStream file = new FileInputStream(fileName)) {
			
			long len = endOffset - startOffset;
			byte[] hashData = new byte[(int)len];
			FileChannel fChan = file.getChannel(); //object to obtain offset current position within the file
			
			fChan.position(startOffset);
			file.read(hashData);
						
			try {

				MessageDigest md = MessageDigest.getInstance("SHA-1");
				this.infoHash = md.digest(hashData);

			} catch (NoSuchAlgorithmException e) {

				System.out.println("error:" + e);
			}

		} catch (IOException e) {
			
			System.out.println("error: " + e);
		}
	}
}
